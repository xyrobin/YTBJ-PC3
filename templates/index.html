<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>生产排产系统</title>
    <link rel="stylesheet" href="/static/style.css">
    <script src="static/Sortable.js"></script>
</head>

<body>
    <div class="container">
        <!-- 左侧工单池 -->
        <div class="order-pool" id="orderPool">
            <h2>待排产工单池</h2>
            <div id="orderList"></div>
        </div>

        <!-- 右侧排产区域 -->
        <div class="scheduling-area">
            <h2>排产区域</h2>
            <div class="shift-container">
                <!-- 班次表格将通过JavaScript动态生成 -->
            </div>
        </div>
    </div>

    <script>
        // 保存滚动位置到localStorage
        window.addEventListener('beforeunload', function() {
            const orderPool = document.getElementById('orderPool');
            const shiftContainer = document.querySelector('.shift-container');
            if (orderPool) localStorage.setItem('orderPoolScrollTop', orderPool.scrollTop);
            if (shiftContainer) localStorage.setItem('shiftContainerScrollTop', shiftContainer.scrollTop);
        });

        // 初始化拖拽功能
        document.addEventListener('DOMContentLoaded', function () {
            // 先初始化班次表格
            initShiftTable();

            // 加载工单数据
            fetch('/api/orders')
                .then(response => response.json())
                .then(orders => {
                    renderOrderPool(orders);
                    // 在班次表格和工单数据都准备好后初始化拖拽
                    initDragAndDrop();
                });
            // 加载已排产工单
            fetch('/api/scheduled_orders')
                .then(response => response.json())
                .then(scheduledOrders => {
                    renderScheduledOrders(scheduledOrders);
                })
                .finally(() => {
                    // 恢复滚动位置
                    const orderPoolScrollTop = localStorage.getItem('orderPoolScrollTop');
                    const shiftContainerScrollTop = localStorage.getItem('shiftContainerScrollTop');
                    if (orderPoolScrollTop) {
                        document.getElementById('orderPool').scrollTop = parseInt(orderPoolScrollTop);
                    }
                    if (shiftContainerScrollTop) {
                        document.querySelector('.shift-container').scrollTop = parseInt(shiftContainerScrollTop);
                    }
                });
        });

        // 渲染工单池
        function renderOrderPool(orders) {
            const orderList = document.getElementById('orderList');
            orderList.innerHTML = '';
            orders.forEach(order => {
                const orderItem = document.createElement('div');
                orderItem.className = 'order-item';
                orderItem.dataset.orderNo = order.scgdh;
                orderItem.dataset.gsxs = order.gsxs; // 添加工时数据属性
                orderItem.innerHTML = `
                    <div class="order-header">工单号: ${order.scgdh}</div>
                    <div class="order-details">
                        <p>工时: ${order.gsxs}小时</p>
                        <p>最早生产日期: ${order.zzscrq}</p>
                    </div>
                `;
                orderList.appendChild(orderItem);
            });
        }

        // 初始化班次表格
        function initShiftTable() {
            // 生成未来三天的日期
            const today = new Date();
            const dates = [
                { date: formatDate(today), label: formatDisplayDate(today) },
                { date: formatDate(new Date(today.getTime() + 86400000)), label: formatDisplayDate(new Date(today.getTime() + 86400000)) },
                { date: formatDate(new Date(today.getTime() + 86400000 * 2)), label: formatDisplayDate(new Date(today.getTime() + 86400000 * 2)) }
            ];

            const container = document.querySelector('.shift-container');
            // 创建表格结构
            container.innerHTML = `
                <table class="schedule-table">
                    <thead>
                        <tr>
                            <th>日期</th>
                            <th>班次</th>
                            <th>时段</th>
                            <th>工单</th>
                        </tr>
                    </thead>
                    <tbody id="scheduleTableBody"></tbody>
                </table>
            `;

            const tableBody = document.getElementById('scheduleTableBody');
            let rows = [];

            // 为每天创建A/B两个班次
            // 修改initShiftTable中的日期循环
            dates.forEach((dateInfo, dateIndex) => {
                // A班 (8:00-20:00) - 包含日期单元格，合并A/B两班共50行
                rows.push(createShiftRow(dateInfo, 'A', '8:00-20:00', dateIndex, true));
                // B班 (20:00-次日8:00) - 不包含日期单元格
                rows.push(createShiftRow(dateInfo, 'B', '20:00-8:00', dateIndex, false));
            });

            tableBody.innerHTML = rows.join('');
        }

        // 创建班次行
        // 修改createShiftRow函数以生成多个时间段行
        function createShiftRow(dateInfo, shift, timeRange, dateIndex, includeDateCell) {
            const timeSlots = generateTimeSlots(shift);
            const rows = [];
        
            // 创建日期和班次标题行
            let headerCells = '';
            if (includeDateCell) {
                // A班包含日期单元格，合并50行（A/B两班各25行）
                headerCells += `<td class="date-cell" rowspan="50">${dateInfo.label}</td>`;
            }
            headerCells += `<td class="shift-cell ${shift === 'B' ? 'b-shift' : ''}" rowspan="25">${shift}班<br>(${timeRange})</td>`;
        
            rows.push(`<tr class="shift-header-row">${headerCells}</tr>`);

            // 为每个时间段创建独立行
            // 假设传入全局索引 offsetIndex 作为班次起始索引
            const offsetIndex = dateIndex * 48 + (shift === 'A' ? 0 : 24);
            timeSlots.forEach((slot, localIndex) => {
                // 第一行需要添加开始标签
                const rowStart = localIndex === 0 ? '</tr>' : '';
                rows.push(`${rowStart}
                <tr class="time-slot-row">
                    <td class="time-slot">${slot}</td>
                    <td class="shift-order-slot" 
                         data-date="${dateInfo.date}" 
                         data-shift="${shift}" 
                         data-time-slot="${slot}" 
                         data-slot-index="${offsetIndex + localIndex}"></td> <!-- 添加索引标识 -->
                </tr>`);
            });

            return rows.join('');
        }

        // 生成班次的时间段（每半小时一个）
        function generateTimeSlots(shift) {
            const slots = [];
            let startHour, endHour;

            if (shift === 'A') {
                startHour = 8; // 8:00
                endHour = 20; // 20:00
            } else {
                startHour = 20; // 20:00
                endHour = 32; // 次日8:00
            }

            // 生成半小时为间隔的时间段
            for (let hour = startHour; hour < endHour; hour++) {
                for (let minute = 0; minute < 60; minute += 30) {
                    const hourStr = hour % 24;
                    const minuteStr = minute.toString().padStart(2, '0');
                    slots.push(`${hourStr}:${minuteStr}`);
                }
            }
            return slots;
        }

        // 辅助函数：格式化显示日期为"YYYY-MM-DD 星期X"
        // 格式化日期显示（带星期，日期和星期分行显示）
        function formatDisplayDate(date) {
            // 手动格式化日期为YYYY-MM-DD格式
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const dateStr = `${year}-${month}-${day}`;

            const weekdayStr = date.toLocaleDateString('zh-CN', { weekday: 'long' });
            return `${dateStr}<br>${weekdayStr}`;
        }

        // 在DOMContentLoaded事件处理函数中添加

        // 初始化拖拽功能
        function initDragAndDrop() {
            // 工单池拖拽源
            const orderPool = document.getElementById('orderList');
            new Sortable(orderPool, {
                group: 'shared',
                animation: 150,
                ghostClass: 'order-ghost',
                // 添加从班次拖回工单池的处理
                onAdd: function (evt) {

                    // console.log("拖动1"+ evt);

                    if (evt.from !== evt.to) { // 确保是从外部拖入工单池
                        const orderNo = evt.item.dataset.orderNo;
                        // 调用取消排产API
                        fetch('/api/unschedule', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ order_no: orderNo })
                        })
                            .then(response => response.json())
                            .then(data => {
                                if (!data.success) {
                                    alert('取消排产失败: ' + data.message);
                                    evt.item.remove(); // 从DOM中移除元素
                                } else {
                                    // 拖拽成功后刷新页面
                                    // alert("刷新？")
                                    location.reload();
                                }
                            });
                    }
                }
            });

            // 班次区域拖拽目标 - 修改选择器为.order-slot
            document.querySelectorAll('.shift-order-slot').forEach(slot => {
                new Sortable(slot, {
                    group: 'shared',
                    animation: 150,
                    onAdd: function (evt) {

                        // console.log("拖动2"+ evt);
                        
                        const orderNo = evt.item.dataset.orderNo;
                        const date = evt.to.dataset.date;
                        const shift = evt.to.dataset.shift;
                        // 自动获取拖入单元格的时间，不再需要手动输入
                        const startTime = evt.to.dataset.timeSlot;
                        const orderDuration = parseFloat(evt.item.dataset.gsxs); // 获取工单工时
                        const currentSlotIndex = parseInt(evt.to.dataset.slotIndex);
                        const slotsToMerge = Math.ceil(orderDuration * 2); // 计算需要合并的单元格数量

                        // 1. 冲突检测
                        let hasConflict = false;
                        console.log("gsxs："+ evt.item.dataset.gsxs);
                        for (let i = 0; i < slotsToMerge; i++) {
                            console.log("冲突检测："+currentSlotIndex + i)
                            const checkSlotIndex = currentSlotIndex + i;
                            // 查找同日期同班次下的目标时间段单元格
                            const checkSlot = document.querySelector(`.shift-order-slot[data-slot-index="${checkSlotIndex}"]`);

                            // 检查条件：单元格存在且已包含工单
                            if (checkSlot.children.length > 0) {
                                console.log(checkSlotIndex + ": "+ checkSlot.children[0].dataset.orderNo);
                                if ( checkSlot.children[0].dataset.orderNo !== orderNo || checkSlot.children.length > 1) {
                                    hasConflict = true;
                                    break;
                                }
                            }
                        }

                        // 2. 处理冲突情况
                        if (hasConflict) {
                            alert('目标时间段存在冲突工单，请选择其他时间段！');
                            // 将工单移回原位置
                            evt.from.appendChild(evt.item);
                            return; // 终止后续操作
                        }

                        // 3. 无冲突时继续排产流程
                        if (startTime) {
                            // 调用排产API
                            fetch('/api/schedule', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    order_no: orderNo,
                                    plan_date: date,
                                    shift: shift,
                                    start_time: startTime
                                })
                            })
                                .then(response => response.json())
                                .then(data => {
                                    if (!data.success) {
                                        alert('排产失败: ' + data.message);
                                        evt.item.remove();
                                    } else {
                                        // alert("刷新？222")
                                        location.reload();
                                    }
                                });
                        }
                    }
                });
            });
        }

        // 辅助函数：格式化日期为YYYY-MM-DD
        function formatDate(date) {
            return date.toISOString().split('T')[0];
        }

        // 创建时间段和工单的对应关系
        // function createTimeSlotAndOrderGrid(dateInfo, shift, startTime, endTime) {
        //     const rows = [];
        //     // 生成时间段和对应的工单区域
        //     for (let i = 0; i < 24; i++) { // 每个班次12小时，每半小时一个时间段，共24个时间段
        //         const hour = Math.floor(i / 2);
        //         const minute = (i % 2) * 30;
        //         const timeSlot = `${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}`;
        //         const timeSlotId = `${dateInfo.date}-${shift}-${i}`;

        //         // 创建时间段行
        //         rows.push(`
        //             <tr class="time-slot-row">
        //                 <td class="date-cell" rowspan="1"></td>
        //                 <td class="shift-cell" rowspan="1"></td>
        //                 <td class="time-slot">${timeSlot}</td>
        //                 <td class="shift-order-slot" data-time-slot="${timeSlotId}"></td>
        //             </tr>
        //         `);
        //     }
        //     return rows.join('');
        // }

        // 根据工时计算工单高度
        function calculateOrderHeight(hours) {
            // 每个时间段行高40px，每0.5小时对应一个时间段高度
            const baseHeight = 30; // 基础高度（半小时）
            return `${baseHeight * (hours / 0.5)}px`;
        }

        // 添加渲染已排产工单的函数
        function renderScheduledOrders(orders) {
            orders.forEach(order => {
                const orderDate = order.jhksrq; // 计划日期
                const orderTime = order.jhkssj.trim(); // 计划开始时间
                const orderDuration = parseFloat(order.gsxs); // 工时
                const orderNo = order.scgdh;
                const shift = getShiftFromTime(orderTime);

                // 找到目标时间段单元格
                const targetSlot = document.querySelector(`.shift-order-slot[data-date="${orderDate}"][data-shift="${shift}"][data-time-slot="${orderTime}"]`);
                if (targetSlot) {
                    // 1. 计算需要合并的单元格数量（每0.5小时一个单元格）
                    const slotsToMerge = Math.ceil(orderDuration * 2);
                    const currentSlotIndex = parseInt(targetSlot.dataset.slotIndex);

                    // 2. 隐藏后续单元格（合并视觉效果）
                    for (let i = 1; i < slotsToMerge; i++) {
                        const nextSlotIndex = currentSlotIndex + i;
                        const nextSlot = document.querySelector(`.shift-order-slot[data-slot-index="${nextSlotIndex}"]`);
                        if (nextSlot) {
                            nextSlot.style.display = 'none'; // 隐藏后续单元格
                        }
                    }

                    // 3. 创建工单元素（保持原高度计算方式）
                    const orderElement = document.createElement('div');
                    orderElement.className = 'order-item';
                    orderElement.dataset.orderNo = orderNo;
                    orderElement.dataset.gsxs = orderDuration;
                    orderElement.style.height = calculateOrderHeight(orderDuration);
                    orderElement.style.width = '100%';
                    orderElement.style.position = 'absolute';
                    orderElement.style.overflow = 'visible';
                    orderElement.innerHTML = `
                        <div class="order-header">${orderNo}</div>
                        <div class="order-details">工时: ${orderDuration}小时</div>
                    `;
                    targetSlot.appendChild(orderElement);
                }
            });
        }

        // 添加辅助函数：根据时间确定班次
        function getShiftFromTime(timeStr) {
            const hour = parseInt(timeStr.split(':')[0]);
            return hour >= 8 && hour < 20 ? 'A' : 'B';
        }

        // 添加辅助函数：将时间转换为时间段索引
        function getSlotIndex(timeStr) {
            const [hours, minutes] = timeStr.split(':').map(Number);
            const totalMinutes = hours * 60 + minutes;
            // 计算从8:00开始的分钟偏移量
            const startMinutes = 8 * 60;
            const offsetMinutes = totalMinutes - startMinutes;
            return Math.floor(offsetMinutes / 30); // 每30分钟一个时间段
        }
    </script>
</body>

</html>